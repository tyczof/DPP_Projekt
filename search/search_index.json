{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DFS w labiryncie","text":"<p>To jest projekt do generowania i rozwi\u0105zywania labirynt\u00f3w za pomoc\u0105 algorytmu Depth-First Search (DFS). Labirynt jest generowany w spos\u00f3b rekursywny, a nast\u0119pnie rozwi\u0105zany przez algorytm DFS, kt\u00f3ry znajduje \u015bcie\u017ck\u0119 od punktu startowego do punktu ko\u0144cowego.</p>"},{"location":"#spis-tresci","title":"Spis tre\u015bci","text":"<ul> <li>Generator Labiryntu</li> <li>Algorytm DFS</li> <li>Wizualizacja</li> </ul>"},{"location":"generator/","title":"Generator Labiryntu","text":"<p>Labirynt jest generowany przy u\u017cyciu algorytmu Depth-First Search (DFS). Algorytm ten tworzy \u015bcie\u017cki mi\u0119dzy kom\u00f3rkami, zaczynaj\u0105c od losowej kom\u00f3rki.</p>"},{"location":"generator/#funkcja-_create_grid_with_cells","title":"Funkcja <code>_create_grid_with_cells</code>","text":"<p>Funkcja <code>_create_grid_with_cells</code> generuje siatk\u0119, kt\u00f3ra b\u0119dzie podstaw\u0105 do tworzenia labiryntu. W siatce znajduj\u0105 si\u0119 zar\u00f3wno \u015bciany, jak i przestrzenie przej\u015bciowe.</p>"},{"location":"generator/#argumenty","title":"Argumenty","text":"<ul> <li><code>width</code> (int): Szeroko\u015b\u0107 siatki (liczba kolumn).</li> <li><code>height</code> (int): Wysoko\u015b\u0107 siatki (liczba wierszy).</li> </ul>"},{"location":"generator/#zwracana-wartosc","title":"Zwracana warto\u015b\u0107","text":"<p>Zwraca 2D list\u0119, gdzie: - <code>1</code> oznacza \u015bcian\u0119 (reprezentowan\u0105 przez <code>TILE_CRATE</code>), - <code>0</code> oznacza pust\u0105 przestrze\u0144 (reprezentowan\u0105 przez <code>TILE_EMPTY</code>).</p>"},{"location":"generator/#kod-funkcji","title":"Kod funkcji","text":"<pre><code>TILE_EMPTY = 0\nTILE_CRATE = 1\n\ndef _create_grid_with_cells(width, height):\n    grid = []\n    for row in range(height):\n        grid.append([])\n        for column in range(width):\n            if column % 2 == 1 and row % 2 == 1:\n                grid[row].append(TILE_EMPTY)\n            elif column == 0 or row == 0 or column == width - 1 or row == height - 1:\n                grid[row].append(TILE_CRATE)\n            else:\n                grid[row].append(TILE_CRATE)\n    return grid\n\n</code></pre>"},{"location":"pathfinding/","title":"Algorytm DFS do znajdowania \u015bcie\u017cki","text":"<p>Algorytm DFS (Depth-First Search) jest popularn\u0105 metod\u0105 wyszukiwania, kt\u00f3ra s\u0142u\u017cy do znajdowania \u015bcie\u017cek w labiryncie, od punktu startowego do punktu ko\u0144cowego. Algorytm dzia\u0142a na zasadzie g\u0142\u0119bokiej eksploracji, odwiedzaj\u0105c wszystkie mo\u017cliwe \u015bcie\u017cki, zapami\u0119tuj\u0105c odwiedzone kom\u00f3rki w stosie i przechodz\u0105c do najg\u0142\u0119bszych \u015bcie\u017cek przed powrotem do wcze\u015bniejszych.</p> <p>Algorytm DFS jest idealny do zastosowa\u0144, w kt\u00f3rych nie jest wymagane znalezienie najkr\u00f3tszej \u015bcie\u017cki, a raczej po prostu jakiejkolwiek \u015bcie\u017cki.</p>"},{"location":"pathfinding/#dziaanie-algorytmu-dfs","title":"Dzia\u0142anie algorytmu DFS","text":"<p>DFS dzia\u0142a poprzez rekurencyjne lub iteracyjne przeszukiwanie labiryntu. Rozpoczyna od punktu startowego i odwiedza ka\u017cd\u0105 kom\u00f3rk\u0119, eksploruj\u0105c mo\u017cliwe \u015bcie\u017cki. W tym algorytmie stos (stack) jest u\u017cywany do zapami\u0119tywania kolejnych krok\u00f3w, a zbi\u00f3r <code>visited</code> \u015bledzi kom\u00f3rki, kt\u00f3re zosta\u0142y ju\u017c odwiedzone.</p> <ol> <li>Zaczynamy od punktu startowego.</li> <li>Przechodzimy do s\u0105siednich kom\u00f3rek.</li> <li>Je\u015bli kom\u00f3rka jest drog\u0105 (pusta przestrze\u0144), dodajemy j\u0105 do stosu i kontynuujemy eksploracj\u0119.</li> <li>Je\u015bli dotrzemy do punktu ko\u0144cowego, zwracamy \u015bcie\u017ck\u0119.</li> <li>Je\u015bli napotkamy martwy punkt (wszystkie mo\u017cliwe \u015bcie\u017cki zosta\u0142y ju\u017c sprawdzone), wracamy do poprzedniej kom\u00f3rki, aby kontynuowa\u0107 eksploracj\u0119 innych \u015bcie\u017cek.</li> </ol>"},{"location":"pathfinding/#funkcja-dfs","title":"Funkcja <code>dfs</code>","text":"<p>Funkcja <code>dfs</code> implementuje algorytm DFS w celu znalezienia \u015bcie\u017cki w labiryncie od punktu startowego do ko\u0144cowego.</p>"},{"location":"pathfinding/#kod-funkcji","title":"Kod funkcji","text":"<pre><code>def dfs(maze, start, end):\n    stack = [(start, [start])] \n    visited = set() \n\n    def get_neighbors(pos):\n        x, y = pos\n        neighbors = []\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 &lt;= nx &lt; len(maze) and 0 &lt;= ny &lt; len(maze[0]) and maze[nx][ny] == TILE_EMPTY:\n                neighbors.append((nx, ny))\n        return neighbors\n\n    while stack:\n        current_pos, path = stack.pop() \n        if current_pos == end: \n            return path\n        if current_pos not in visited:\n            visited.add(current_pos) \n            for neighbor in get_neighbors(current_pos): \n                if neighbor not in visited:\n                    stack.append((neighbor, path + [neighbor]))\n    return None  \n</code></pre>"},{"location":"visualization/","title":"Wizualizacja Labiryntu","text":"<p>Labirynt oraz \u015bcie\u017cka s\u0105 wizualizowane za pomoc\u0105 biblioteki <code>Matplotlib</code>. Dzi\u0119ki tej bibliotece mo\u017cna przedstawi\u0107 struktur\u0119 labiryntu oraz wyr\u00f3\u017cni\u0107 na nim \u015bcie\u017ck\u0119 rozwi\u0105zania. W wizualizacji labiryntu \u015bciany s\u0105 przedstawiane w kolorze czarnym, a przestrzenie w bia\u0142ym. Dodatkowo, je\u015bli istnieje rozwi\u0105zanie, \u015bcie\u017cka jest zaznaczona na zielono, co pozwala na \u0142atwe \u015bledzenie przej\u015bcia od punktu startowego do punktu ko\u0144cowego.</p>"},{"location":"visualization/#funkcja-draw_maze","title":"Funkcja <code>draw_maze</code>","text":"<p>Funkcja <code>draw_maze</code> odpowiada za rysowanie labiryntu w formie obrazu. U\u017cywa ona funkcji <code>imshow</code> z biblioteki <code>Matplotlib</code>, aby przedstawi\u0107 labirynt w postaci obrazka. \u015aciany s\u0105 rysowane na czarno, a \u015bcie\u017cki s\u0105 bia\u0142e. Opcjonalnie, je\u017celi podana jest lista \u015bcie\u017cki, to zostaje ona zaznaczona na zielono.</p>"},{"location":"visualization/#opis","title":"Opis","text":"<p>Funkcja <code>draw_maze</code> wykonuje nast\u0119puj\u0105ce kroki:</p> <ol> <li>Zamienia dwuwymiarow\u0105 list\u0119 reprezentuj\u0105c\u0105 labirynt (<code>maze</code>) na obiekt typu <code>numpy.array</code>.</li> <li>U\u017cywa funkcji <code>imshow</code> z <code>Matplotlib</code> do wy\u015bwietlenia labiryntu. Ustawia map\u0119 kolor\u00f3w na <code>'binary'</code>, co oznacza, \u017ce \u015bciany b\u0119d\u0105 czarne, a przestrze\u0144 wewn\u0119trzna bia\u0142a.</li> <li>Je\u017celi dostarczona zostanie \u015bcie\u017cka (parametr <code>path</code>), funkcja narysuje j\u0105 na zielono, wykorzystuj\u0105c funkcj\u0119 <code>plot</code> z <code>Matplotlib</code>, aby pod\u015bwietli\u0107 wszystkie punkty \u015bcie\u017cki.</li> </ol>"},{"location":"visualization/#kod-funkcji","title":"Kod funkcji","text":"<pre><code>def draw_maze(maze, path=None):\n    rows, cols = len(maze), len(maze[0])\n    maze_image = np.array(maze)  \n\n    fig, ax = plt.subplots()  \n    ax.imshow(maze_image, cmap='binary', origin='upper')  \n\n    if path:\n        path_x, path_y = zip(*path) \n        ax.plot(path_y, path_x, color='g', linewidth=0, marker='o', linestyle='')  \n\n    ax.set_xticks(np.arange(-.5, cols, 1)) \n    ax.set_yticks(np.arange(-.5, rows, 1))  \n    ax.set_xticklabels([]) \n    ax.set_yticklabels([])  \n    ax.grid(color='gray', linestyle='-', linewidth=1) \n\n    plt.show() \n</code></pre>"}]}